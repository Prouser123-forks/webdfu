{"mappings":"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","sources":["./node_modules/file-saver/dist/FileSaver.min.js","./node_modules/@parcel/scope-hoisting/lib/helpers.js","./node_modules/process/browser.js","../core.ts","../process.ts","../node_modules/nanoevents/index.js","../index.ts","./log.ts","./index.ts"],"sourcesContent":["(function(a,b){if(\"function\"==typeof define&&define.amd)define([],b);else if(\"undefined\"!=typeof exports)b();else{b(),a.FileSaver={exports:{}}.exports}})(this,function(){\"use strict\";function b(a,b){return\"undefined\"==typeof b?b={autoBom:!1}:\"object\"!=typeof b&&(console.warn(\"Deprecated: Expected third argument to be a object\"),b={autoBom:!b}),b.autoBom&&/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(a.type)?new Blob([\"\\uFEFF\",a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open(\"GET\",a),d.responseType=\"blob\",d.onload=function(){g(d.response,b,c)},d.onerror=function(){console.error(\"could not download file\")},d.send()}function d(a){var b=new XMLHttpRequest;b.open(\"HEAD\",a,!1);try{b.send()}catch(a){}return 200<=b.status&&299>=b.status}function e(a){try{a.dispatchEvent(new MouseEvent(\"click\"))}catch(c){var b=document.createEvent(\"MouseEvents\");b.initMouseEvent(\"click\",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b)}}var f=\"object\"==typeof window&&window.window===window?window:\"object\"==typeof self&&self.self===self?self:\"object\"==typeof global&&global.global===global?global:void 0,a=f.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),g=f.saveAs||(\"object\"!=typeof window||window!==f?function(){}:\"download\"in HTMLAnchorElement.prototype&&!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement(\"a\");g=g||b.name||\"download\",j.download=g,j.rel=\"noopener\",\"string\"==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target=\"_blank\")):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href)},4E4),setTimeout(function(){e(j)},0))}:\"msSaveOrOpenBlob\"in navigator?function(f,g,h){if(g=g||f.name||\"download\",\"string\"!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement(\"a\");i.href=f,i.target=\"_blank\",setTimeout(function(){e(i)})}}:function(b,d,e,g){if(g=g||open(\"\",\"_blank\"),g&&(g.document.title=g.document.body.innerText=\"downloading...\"),\"string\"==typeof b)return c(b,d,e);var h=\"application/octet-stream\"===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\\/[\\d]+/.test(navigator.userAgent);if((j||h&&i||a)&&\"undefined\"!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,\"data:attachment/file;\"),g?g.location.href=a:location=a,g=null},k.readAsDataURL(b)}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m)},4E4)}});f.saveAs=g.saveAs=g,\"undefined\"!=typeof module&&(module.exports=g)});\n\n//# sourceMappingURL=FileSaver.min.js.map","var $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$export(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","export type DFUseMemorySegment = {\n  start: number;\n  end: number;\n  sectorSize: number;\n\n  readable: boolean;\n  erasable: boolean;\n  writable: boolean;\n};\n\nexport enum DFUseCommands {\n  GET_COMMANDS = 0x00,\n  SET_ADDRESS = 0x21,\n  ERASE_SECTOR = 0x41,\n}\n\nexport type WebDFUSettings = {\n  name?: string;\n  configuration: USBConfiguration;\n  interface: USBInterface;\n  alternate: USBAlternateInterface;\n};\n\nexport type WebDFUDeviceDescriptor = {\n  bLength: number;\n  bDescriptorType: number;\n  bcdUSB: number;\n  bDeviceClass: number;\n  bDeviceSubClass: number;\n  bDeviceProtocol: number;\n  bMaxPacketSize: number;\n  idVendor: number;\n  idProduct: number;\n  bcdDevice: number;\n  iManufacturer: number;\n  iProduct: number;\n  iSerialNumber: number;\n  bNumConfigurations: number;\n};\n\nexport type WebDFUFunctionalDescriptor = {\n  bLength: number;\n  bDescriptorType: number;\n  bmAttributes: number;\n  wDetachTimeOut: number;\n  wTransferSize: number;\n  bcdDFUVersion: number;\n};\n\nexport type WebDFUInterfaceDescriptor = {\n  bLength: number;\n  bDescriptorType: number;\n  bInterfaceNumber: number;\n  bAlternateSetting: number;\n  bNumEndpoints: number;\n  bInterfaceClass: number;\n  bInterfaceSubClass: number;\n  bInterfaceProtocol: number;\n  iInterface: number;\n  descriptors: (WebDFUFunctionalDescriptor | WebDFUInterfaceSubDescriptor)[];\n};\n\nexport type WebDFUInterfaceSubDescriptor = {\n  descData: DataView;\n  bLength: number;\n  bDescriptorType: number;\n  bmAttributes: number;\n  wDetachTimeOut: number;\n  wTransferSize: number;\n  bcdDFUVersion: number;\n};\n\nexport type WebDFUEvent = {\n  init: () => void;\n  connect: () => void;\n  disconnect: (error?: Error) => void;\n};\n\nexport type WebDFUOptions = {\n  forceInterfacesName?: boolean;\n};\n\nexport type WebDFUProperties = {\n  WillDetach: boolean;\n  ManifestationTolerant: boolean;\n  CanUpload: boolean;\n  CanDownload: boolean;\n  TransferSize: number;\n  DetachTimeOut: number;\n  DFUVersion: number;\n};\n\nexport type WebDFULog = Record<\"info\" | \"warning\", (msg: string) => void> & {\n  progress: (done: number, total?: number) => void;\n};\n\nexport const WebDFUType: Record<\"DFU\" | \"SDFUse\", number> = {\n  DFU: 1,\n  SDFUse: 2,\n};\n\nexport class WebDFUError extends Error {}\n\n// Parse descriptors\nexport function parseMemoryDescriptor(desc: string): { name: string; segments: DFUseMemorySegment[] } {\n  const nameEndIndex = desc.indexOf(\"/\");\n  if (!desc.startsWith(\"@\") || nameEndIndex == -1) {\n    throw new WebDFUError(`Not a DfuSe memory descriptor: \"${desc}\"`);\n  }\n\n  const name = desc.substring(1, nameEndIndex).trim();\n  const segmentString = desc.substring(nameEndIndex);\n\n  let segments = [];\n\n  const sectorMultipliers: Record<string, number> = {\n    \" \": 1,\n    B: 1,\n    K: 1024,\n    M: 1048576,\n  };\n\n  let contiguousSegmentRegex = /\\/\\s*(0x[0-9a-fA-F]{1,8})\\s*\\/(\\s*[0-9]+\\s*\\*\\s*[0-9]+\\s?[ BKM]\\s*[abcdefg]\\s*,?\\s*)+/g;\n  let contiguousSegmentMatch: RegExpExecArray | null;\n  while ((contiguousSegmentMatch = contiguousSegmentRegex.exec(segmentString))) {\n    let segmentRegex = /([0-9]+)\\s*\\*\\s*([0-9]+)\\s?([ BKM])\\s*([abcdefg])\\s*,?\\s*/g;\n    let startAddress = parseInt(contiguousSegmentMatch?.[1] ?? \"\", 16);\n    let segmentMatch: RegExpExecArray | null;\n    while ((segmentMatch = segmentRegex.exec(contiguousSegmentMatch[0]!))) {\n      let sectorCount = parseInt(segmentMatch[1]!, 10);\n      let sectorSize = parseInt(segmentMatch[2]!) * (sectorMultipliers[segmentMatch?.[3] ?? \"\"] ?? 0);\n      let properties = (segmentMatch?.[4] ?? \"\")?.charCodeAt(0) - \"a\".charCodeAt(0) + 1;\n\n      let segment = {\n        start: startAddress,\n        sectorSize: sectorSize,\n        end: startAddress + sectorSize * sectorCount,\n        readable: (properties & 0x1) != 0,\n        erasable: (properties & 0x2) != 0,\n        writable: (properties & 0x4) != 0,\n      };\n\n      segments.push(segment);\n\n      startAddress += sectorSize * sectorCount;\n    }\n  }\n\n  return { name, segments };\n}\n\nexport function parseDeviceDescriptor(data: DataView): WebDFUDeviceDescriptor {\n  return {\n    bLength: data.getUint8(0),\n    bDescriptorType: data.getUint8(1),\n    bcdUSB: data.getUint16(2, true),\n    bDeviceClass: data.getUint8(4),\n    bDeviceSubClass: data.getUint8(5),\n    bDeviceProtocol: data.getUint8(6),\n    bMaxPacketSize: data.getUint8(7),\n    idVendor: data.getUint16(8, true),\n    idProduct: data.getUint16(10, true),\n    bcdDevice: data.getUint16(12, true),\n    iManufacturer: data.getUint8(14),\n    iProduct: data.getUint8(15),\n    iSerialNumber: data.getUint8(16),\n    bNumConfigurations: data.getUint8(17),\n  };\n}\n\nexport function parseFunctionalDescriptor(data: DataView): WebDFUFunctionalDescriptor {\n  return {\n    bLength: data.getUint8(0),\n    bDescriptorType: data.getUint8(1),\n    bmAttributes: data.getUint8(2),\n    wDetachTimeOut: data.getUint16(3, true),\n    wTransferSize: data.getUint16(5, true),\n    bcdDFUVersion: data.getUint16(7, true),\n  };\n}\n\nexport function parseInterfaceDescriptor(data: DataView): WebDFUInterfaceDescriptor {\n  return {\n    bLength: data.getUint8(0),\n    bDescriptorType: data.getUint8(1),\n    bInterfaceNumber: data.getUint8(2),\n    bAlternateSetting: data.getUint8(3),\n    bNumEndpoints: data.getUint8(4),\n    bInterfaceClass: data.getUint8(5),\n    bInterfaceSubClass: data.getUint8(6),\n    bInterfaceProtocol: data.getUint8(7),\n    iInterface: data.getUint8(8),\n    descriptors: [],\n  };\n}\n\nexport function parseSubDescriptors(descriptorData: DataView) {\n  const DT_INTERFACE = 4;\n  // const DT_ENDPOINT = 5;\n  const DT_DFU_FUNCTIONAL = 0x21;\n  const USB_CLASS_APP_SPECIFIC = 0xfe;\n  const USB_SUBCLASS_DFU = 0x01;\n\n  let remainingData: DataView = descriptorData;\n  let descriptors = [];\n  let currIntf;\n  let inDfuIntf = false;\n\n  while (remainingData.byteLength > 2) {\n    let bLength = remainingData.getUint8(0);\n    let bDescriptorType = remainingData.getUint8(1);\n    let descData = new DataView(remainingData.buffer.slice(0, bLength));\n    if (bDescriptorType == DT_INTERFACE) {\n      currIntf = parseInterfaceDescriptor(descData);\n      if (currIntf.bInterfaceClass == USB_CLASS_APP_SPECIFIC && currIntf.bInterfaceSubClass == USB_SUBCLASS_DFU) {\n        inDfuIntf = true;\n      } else {\n        inDfuIntf = false;\n      }\n      descriptors.push(currIntf);\n    } else if (inDfuIntf && bDescriptorType == DT_DFU_FUNCTIONAL) {\n      let funcDesc = parseFunctionalDescriptor(descData);\n      descriptors.push(funcDesc);\n      currIntf?.descriptors.push(funcDesc);\n    } else {\n      let desc = {\n        bLength: bLength,\n        bDescriptorType: bDescriptorType,\n        descData: descData,\n      } as WebDFUInterfaceSubDescriptor;\n      descriptors.push(desc);\n      if (currIntf) {\n        currIntf.descriptors.push(desc);\n      }\n    }\n    remainingData = new DataView(remainingData.buffer.slice(bLength));\n  }\n\n  return descriptors;\n}\n\nexport function parseConfigurationDescriptor(data: DataView) {\n  let descriptorData = new DataView(data.buffer.slice(9));\n  let descriptors = parseSubDescriptors(descriptorData);\n\n  return {\n    bLength: data.getUint8(0),\n    bDescriptorType: data.getUint8(1),\n    wTotalLength: data.getUint16(2, true),\n    bNumInterfaces: data.getUint8(4),\n    bConfigurationValue: data.getUint8(5),\n    iConfiguration: data.getUint8(6),\n    bmAttributes: data.getUint8(7),\n    bMaxPower: data.getUint8(8),\n    descriptors: descriptors,\n  };\n}\n","import { createNanoEvents } from \"nanoevents\";\nimport type { Emitter } from \"nanoevents\";\n\nexport type WebDFUProcessReadEvents = {\n  process: (done: number, total?: number) => void;\n  error: (error: any) => void;\n  end: (data: Blob) => void;\n};\n\nexport type WebDFUProcessWriteEvents = {\n  \"erase/start\": () => void;\n  \"erase/process\": WebDFUProcessEraseEvents[\"process\"];\n  \"erase/end\": WebDFUProcessEraseEvents[\"end\"];\n\n  \"write/start\": () => void;\n  \"write/process\": (bytesSent: number, expectedSize: number) => void;\n  \"write/end\": (bytesSent: number) => void;\n\n  verify: (status: { status: number; pollTimeout: number; state: number }) => void;\n\n  error: (error: any) => void;\n  end: () => void;\n};\n\nexport type WebDFUProcessEraseEvents = {\n  process: (bytesSent: number, expectedSize: number) => void;\n  error: (error: any) => void;\n  end: () => void;\n};\n\nexport interface WebDFUProcess<T> {\n  events: Emitter<T>;\n}\n\nexport class WebDFUProcessRead implements WebDFUProcess<WebDFUProcessReadEvents> {\n  events = createNanoEvents<WebDFUProcessReadEvents>();\n}\n\nexport class WebDFUProcessWrite implements WebDFUProcess<WebDFUProcessWriteEvents> {\n  events = createNanoEvents<WebDFUProcessWriteEvents>();\n}\n\nexport class WebDFUProcessErase implements WebDFUProcess<WebDFUProcessEraseEvents> {\n  events = createNanoEvents<WebDFUProcessEraseEvents>();\n}\n","export let createNanoEvents = () => ({\n  events: {},\n  emit(event, ...args) {\n    ;(this.events[event] || []).forEach(i => i(...args))\n  },\n  on(event, cb) {\n    ;(this.events[event] = this.events[event] || []).push(cb)\n    return () =>\n      (this.events[event] = (this.events[event] || []).filter(i => i !== cb))\n  }\n})\n","import { createNanoEvents } from \"nanoevents\";\n\nimport {\n  WebDFUSettings,\n  WebDFUEvent,\n  WebDFUOptions,\n  WebDFUProperties,\n  WebDFUType,\n  WebDFULog,\n  WebDFUInterfaceSubDescriptor,\n  WebDFUInterfaceDescriptor,\n  parseMemoryDescriptor,\n  DFUseMemorySegment,\n  DFUseCommands,\n} from \"./core\";\nimport { WebDFUProcessErase, WebDFUProcessRead, WebDFUProcessWrite } from \"./process\";\nimport { parseConfigurationDescriptor, WebDFUError } from \"./core\";\n\nexport * from \"./core\";\n\nexport const dfuCommands = {\n  DETACH: 0x00,\n  DOWNLOAD: 0x01,\n  UPLOAD: 0x02,\n  GETSTATUS: 0x03,\n  CLRSTATUS: 0x04,\n  GETSTATE: 0x05,\n  ABORT: 0x06,\n\n  appIDLE: 0,\n  appDETACH: 1,\n\n  dfuIDLE: 2,\n  dfuDOWNLOAD_SYNC: 3,\n  dfuDNBUSY: 4,\n  dfuDOWNLOAD_IDLE: 5,\n  dfuMANIFEST_SYNC: 6,\n  dfuMANIFEST: 7,\n  dfuMANIFEST_WAIT_RESET: 8,\n  dfuUPLOAD_IDLE: 9,\n  dfuERROR: 10,\n\n  STATUS_OK: 0x0,\n};\n\nexport class WebDFU {\n  events = createNanoEvents<WebDFUEvent>();\n\n  interfaces: WebDFUSettings[] = [];\n  properties?: WebDFUProperties;\n\n  connected: boolean = false;\n\n  dfuseStartAddress: number = NaN;\n  dfuseMemoryInfo?: { name: string; segments: DFUseMemorySegment[] };\n  currentInterfaceSettings?: WebDFUSettings;\n\n  constructor(\n    public readonly device: USBDevice,\n    public readonly settings: WebDFUOptions = {},\n    private readonly log: WebDFULog\n  ) {}\n\n  get type(): number {\n    if (this.properties?.DFUVersion == 0x011a && this.currentInterfaceSettings?.alternate.interfaceProtocol == 0x02) {\n      return WebDFUType.SDFUse;\n    }\n\n    return WebDFUType.DFU;\n  }\n\n  async init(): Promise<void> {\n    this.interfaces = await this.findDfuInterfaces();\n    this.events.emit(\"init\");\n  }\n\n  async connect(interfaceIndex: number): Promise<void> {\n    if (!this.device.opened) {\n      await this.device.open();\n    }\n\n    // Attempt to parse the DFU functional descriptor\n    let desc: WebDFUProperties | null = null;\n    try {\n      desc = await this.getDFUDescriptorProperties();\n    } catch (error) {\n      this.events.emit(\"disconnect\", error);\n      throw error;\n    }\n\n    const intrf = this.interfaces[interfaceIndex];\n\n    if (!intrf) {\n      throw new WebDFUError(\"Interface not found\");\n    }\n\n    this.currentInterfaceSettings = intrf;\n    if (this.currentInterfaceSettings.name) {\n      this.dfuseMemoryInfo = parseMemoryDescriptor(this.currentInterfaceSettings.name);\n    }\n\n    if (desc) {\n      this.properties = desc;\n    }\n\n    try {\n      await this.open();\n    } catch (error) {\n      this.events.emit(\"disconnect\", error);\n      throw error;\n    }\n\n    this.events.emit(\"connect\");\n  }\n\n  async close() {\n    await this.device.close();\n    this.events.emit(\"disconnect\");\n  }\n\n  read(xferSize: number, maxSize: number): WebDFUProcessRead {\n    if (!this) {\n      throw new WebDFUError(\"Required initialized driver\");\n    }\n\n    const process = new WebDFUProcessRead();\n\n    try {\n      let blob: Promise<Blob>;\n      if (this.type === WebDFUType.SDFUse) {\n        blob = this.do_dfuse_read(process, xferSize, maxSize);\n      } else {\n        blob = this.do_read(process, xferSize, maxSize);\n      }\n\n      blob.then((data) => process.events.emit(\"end\", data)).catch((error) => process.events.emit(\"error\", error));\n    } catch (error) {\n      process.events.emit(\"error\", error);\n    }\n\n    return process;\n  }\n\n  write(xfer_size: number, data: ArrayBuffer, manifestationTolerant: boolean): WebDFUProcessWrite {\n    if (!this) {\n      throw new WebDFUError(\"Required initialized driver\");\n    }\n\n    let process = new WebDFUProcessWrite();\n\n    setTimeout(() => {\n      try {\n        let result: Promise<void>;\n\n        if (this.type === WebDFUType.SDFUse) {\n          result = this.do_dfuse_write(process, xfer_size, data);\n        } else {\n          result = this.do_write(process, xfer_size, data, manifestationTolerant);\n        }\n\n        result.then(() => process.events.emit(\"end\")).catch((error) => process.events.emit(\"error\", error));\n      } catch (error) {\n        process.events.on(\"error\", error);\n      }\n    }, 0);\n\n    return process;\n  }\n\n  // Attempt to read the DFU functional descriptor\n  // TODO: read the selected configuration's descriptor\n  private async getDFUDescriptorProperties(): Promise<WebDFUProperties | null> {\n    const data = await this.readConfigurationDescriptor(0);\n\n    let configDesc = parseConfigurationDescriptor(data);\n    let funcDesc: WebDFUInterfaceSubDescriptor | null = null;\n    let configValue = this.device.configuration?.configurationValue;\n    if (configDesc.bConfigurationValue == configValue) {\n      for (let desc of configDesc.descriptors) {\n        if (desc.bDescriptorType == 0x21 && desc.hasOwnProperty(\"bcdDFUVersion\")) {\n          funcDesc = desc as WebDFUInterfaceSubDescriptor;\n          break;\n        }\n      }\n    }\n\n    if (!funcDesc) {\n      return null;\n    }\n\n    return {\n      WillDetach: (funcDesc.bmAttributes & 0x08) != 0,\n      ManifestationTolerant: (funcDesc.bmAttributes & 0x04) != 0,\n      CanUpload: (funcDesc.bmAttributes & 0x02) != 0,\n      CanDownload: (funcDesc.bmAttributes & 0x01) != 0,\n      TransferSize: funcDesc.wTransferSize,\n      DetachTimeOut: funcDesc.wDetachTimeOut,\n      DFUVersion: funcDesc.bcdDFUVersion,\n    };\n  }\n\n  private async findDfuInterfaces(): Promise<WebDFUSettings[]> {\n    const interfaces = [];\n\n    for (let conf of this.device.configurations) {\n      for (let intf of conf.interfaces) {\n        for (let alt of intf.alternates) {\n          if (\n            alt.interfaceClass == 0xfe &&\n            alt.interfaceSubclass == 0x01 &&\n            (alt.interfaceProtocol == 0x01 || alt.interfaceProtocol == 0x02)\n          ) {\n            interfaces.push({\n              configuration: conf,\n              interface: intf,\n              alternate: alt,\n              name: alt.interfaceName,\n            });\n          }\n        }\n      }\n    }\n\n    if (this.settings.forceInterfacesName) {\n      // Need force\n      await this.fixInterfaceNames(interfaces);\n    }\n\n    return interfaces;\n  }\n\n  private async fixInterfaceNames(interfaces: WebDFUSettings[]) {\n    // Check if any interface names were not read correctly\n    if (interfaces.some((intf) => intf.name == null)) {\n      await this.device.open();\n      await this.device.selectConfiguration(1);\n\n      let mapping = await this.readInterfaceNames();\n\n      for (let intf of interfaces) {\n        if (intf.name === null) {\n          let configIndex = intf.configuration.configurationValue;\n          let intfNumber = intf[\"interface\"].interfaceNumber;\n          let alt = intf.alternate.alternateSetting;\n          intf.name = mapping?.[configIndex]?.[intfNumber]?.[alt]?.toString();\n        }\n      }\n    }\n  }\n\n  private async readStringDescriptor(index: number, langID = 0) {\n    const GET_DESCRIPTOR = 0x06;\n    const DT_STRING = 0x03;\n    const wValue = (DT_STRING << 8) | index;\n\n    const request_setup: USBControlTransferParameters = {\n      requestType: \"standard\",\n      recipient: \"device\",\n      request: GET_DESCRIPTOR,\n      value: wValue,\n      index: langID,\n    };\n\n    // Read enough for bLength\n    let result = await this.device.controlTransferIn(request_setup, 1);\n\n    if (result.data && result.status == \"ok\") {\n      // Retrieve the full descriptor\n      const bLength = result.data.getUint8(0);\n      result = await this.device.controlTransferIn(request_setup, bLength);\n      if (result.data && result.status == \"ok\") {\n        const len = (bLength - 2) / 2;\n        let u16_words = [];\n        for (let i = 0; i < len; i++) {\n          u16_words.push(result.data.getUint16(2 + i * 2, true));\n        }\n        if (langID == 0) {\n          // Return the langID array\n          return u16_words;\n        } else {\n          // Decode from UCS-2 into a string\n          return String.fromCharCode.apply(String, u16_words);\n        }\n      }\n    }\n\n    throw new WebDFUError(`Failed to read string descriptor ${index}: ${result.status}`);\n  }\n\n  // @ts-ignore\n  private async readDeviceDescriptor(): Promise<DataView> {\n    const GET_DESCRIPTOR = 0x06;\n    const DT_DEVICE = 0x01;\n    const wValue = DT_DEVICE << 8;\n\n    const result = await this.device.controlTransferIn(\n      {\n        requestType: \"standard\",\n        recipient: \"device\",\n        request: GET_DESCRIPTOR,\n        value: wValue,\n        index: 0,\n      },\n      18\n    );\n\n    if (!result.data || result.status !== \"ok\") {\n      throw new WebDFUError(`Failed to read device descriptor: ${result.status}`);\n    }\n\n    return result.data;\n  }\n\n  private async readInterfaceNames() {\n    const DT_INTERFACE = 4;\n\n    let configs: Record<number, Record<number, Record<number, number>>> = {};\n    let allStringIndices = new Set<any>();\n    for (let configIndex = 0; configIndex < this.device.configurations.length; configIndex++) {\n      const rawConfig = await this.readConfigurationDescriptor(configIndex);\n      let configDesc = parseConfigurationDescriptor(rawConfig);\n      let configValue = configDesc.bConfigurationValue;\n      configs[configValue] = {};\n\n      // Retrieve string indices for interface names\n      for (let desc of configDesc.descriptors) {\n        if (desc.bDescriptorType === DT_INTERFACE) {\n          desc = desc as WebDFUInterfaceDescriptor;\n\n          if (!configs[configValue]?.[desc.bInterfaceNumber]) {\n            configs[configValue]![desc.bInterfaceNumber] = {};\n          }\n\n          configs[configValue]![desc.bInterfaceNumber]![desc.bAlternateSetting] = desc.iInterface;\n\n          if (desc.iInterface > 0) {\n            allStringIndices.add(desc.iInterface);\n          }\n        }\n      }\n    }\n\n    let strings: any = {};\n\n    // Retrieve interface name strings\n    for (let index of allStringIndices) {\n      try {\n        strings[index] = await this.readStringDescriptor(index, 0x0409);\n      } catch (error) {\n        console.log(error);\n        strings[index] = null;\n      }\n    }\n\n    for (let config of Object.values(configs)) {\n      for (let intf of Object.values(config)) {\n        for (let alt in intf) {\n          intf[alt] = strings[intf[alt]!];\n        }\n      }\n    }\n\n    return configs;\n  }\n\n  private async readConfigurationDescriptor(index: number): Promise<DataView> {\n    const GET_DESCRIPTOR = 0x06;\n    const DT_CONFIGURATION = 0x02;\n    const wValue = (DT_CONFIGURATION << 8) | index;\n\n    const setup: USBControlTransferParameters = {\n      requestType: \"standard\",\n      recipient: \"device\",\n      request: GET_DESCRIPTOR,\n      value: wValue,\n      index: 0,\n    };\n\n    const descriptorSize = await this.device.controlTransferIn(setup, 4);\n\n    if (!descriptorSize.data || descriptorSize.status !== \"ok\") {\n      throw new WebDFUError(`controlTransferIn error. [status]: ${descriptorSize.status}`);\n    }\n\n    // Read out length of the configuration descriptor\n    let wLength = descriptorSize.data.getUint16(2, true);\n\n    const descriptor = await this.device.controlTransferIn(setup, wLength);\n\n    if (!descriptor.data || descriptor.status !== \"ok\") {\n      throw new WebDFUError(`controlTransferIn error. [status]: ${descriptor.status}`);\n    }\n\n    return descriptor.data;\n  }\n\n  // Control\n  async open() {\n    if (!this.currentInterfaceSettings) {\n      throw new WebDFUError(\"Required selected interface\");\n    }\n\n    const confValue = this.currentInterfaceSettings.configuration.configurationValue;\n\n    if (!this.device.configuration || this.device.configuration.configurationValue !== confValue) {\n      await this.device.selectConfiguration(confValue);\n    }\n\n    if (!this.device.configuration) {\n      throw new WebDFUError(`Couldn't select the configuration '${confValue}'`);\n    }\n\n    const intfNumber = this.currentInterfaceSettings[\"interface\"].interfaceNumber;\n    if (!this.device.configuration.interfaces[intfNumber]?.claimed) {\n      await this.device.claimInterface(intfNumber);\n    }\n\n    const altSetting = this.currentInterfaceSettings.alternate.alternateSetting;\n    let intf = this.device.configuration.interfaces[intfNumber];\n    if (!intf?.alternate || intf.alternate.alternateSetting != altSetting) {\n      await this.device.selectAlternateInterface(intfNumber, altSetting);\n    }\n  }\n\n  detach() {\n    return this.requestOut(dfuCommands.DETACH, undefined, 1000);\n  }\n\n  abort() {\n    return this.requestOut(dfuCommands.ABORT);\n  }\n\n  async waitDisconnected(timeout: number) {\n    let device = this;\n    let usbDevice = this.device;\n\n    return new Promise((resolve, reject) => {\n      let timeoutID: number;\n\n      function onDisconnect(event: USBConnectionEvent) {\n        if (event.device === usbDevice) {\n          if (timeout > 0) {\n            clearTimeout(timeoutID);\n          }\n          device.connected = false;\n          navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n          event.stopPropagation();\n          resolve(device);\n        }\n      }\n\n      if (timeout > 0) {\n        timeoutID = window.setTimeout(() => {\n          navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n\n          if (device.connected) {\n            reject(\"Disconnect timeout expired\");\n          }\n        }, timeout);\n      } else {\n        navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n      }\n    });\n  }\n\n  // Status\n  async isError() {\n    try {\n      const state = await this.getStatus();\n\n      if (!state) {\n        return true;\n      }\n\n      return state?.state == dfuCommands.dfuERROR;\n    } catch (_) {\n      return true;\n    }\n  }\n\n  getState() {\n    return this.requestIn(dfuCommands.GETSTATE, 1).then(\n      (data) => Promise.resolve(data.getUint8(0)),\n      (error) => Promise.reject(\"DFU GETSTATE failed: \" + error)\n    );\n  }\n\n  getStatus() {\n    return this.requestIn(dfuCommands.GETSTATUS, 6).then(\n      (data) =>\n        Promise.resolve({\n          status: data.getUint8(0),\n          pollTimeout: data.getUint32(1, true) & 0xffffff,\n          state: data.getUint8(4),\n        }),\n      (error) => Promise.reject(\"DFU GETSTATUS failed: \" + error)\n    );\n  }\n\n  clearStatus() {\n    return this.requestOut(dfuCommands.CLRSTATUS);\n  }\n\n  /* Driver options */\n  private get intfNumber(): number {\n    if (!this.currentInterfaceSettings) {\n      throw new WebDFUError(\"Required selected interface\");\n    }\n\n    return this.currentInterfaceSettings.interface.interfaceNumber;\n  }\n\n  private async requestOut(bRequest: number, data?: BufferSource, wValue = 0): Promise<number> {\n    try {\n      const result = await this.device.controlTransferOut(\n        {\n          requestType: \"class\",\n          recipient: \"interface\",\n          request: bRequest,\n          value: wValue,\n          index: this.intfNumber,\n        },\n        data\n      );\n\n      if (result.status !== \"ok\") {\n        throw new WebDFUError(result.status);\n      }\n\n      return result.bytesWritten;\n    } catch (error) {\n      throw new WebDFUError(\"ControlTransferOut failed: \" + error);\n    }\n  }\n\n  private async requestIn(bRequest: number, wLength: number, wValue = 0): Promise<DataView> {\n    try {\n      const result = await this.device.controlTransferIn(\n        {\n          requestType: \"class\",\n          recipient: \"interface\",\n          request: bRequest,\n          value: wValue,\n          index: this.intfNumber,\n        },\n        wLength\n      );\n\n      if (result.status !== \"ok\" || !result.data) {\n        throw new WebDFUError(result.status);\n      }\n\n      return result.data;\n    } catch (error) {\n      throw new WebDFUError(\"ControlTransferIn failed: \" + error);\n    }\n  }\n\n  private download(data: ArrayBuffer, blockNum: number) {\n    return this.requestOut(dfuCommands.DOWNLOAD, data, blockNum);\n  }\n\n  private upload(length: number, blockNum: number) {\n    return this.requestIn(dfuCommands.UPLOAD, length, blockNum);\n  }\n\n  // IDLE\n  private async abortToIdle() {\n    await this.abort();\n    let state = await this.getState();\n    if (state == dfuCommands.dfuERROR) {\n      await this.clearStatus();\n      state = await this.getState();\n    }\n    if (state != dfuCommands.dfuIDLE) {\n      throw new WebDFUError(\"Failed to return to idle state after abort: state \" + state);\n    }\n  }\n\n  private async poll_until(state_predicate: (state: number) => boolean) {\n    let dfu_status = await this.getStatus();\n\n    function async_sleep(duration_ms: number) {\n      return new Promise((resolve) => {\n        setTimeout(resolve, duration_ms);\n      });\n    }\n\n    while (!state_predicate(dfu_status.state) && dfu_status.state != dfuCommands.dfuERROR) {\n      await async_sleep(dfu_status.pollTimeout);\n      dfu_status = await this.getStatus();\n    }\n\n    return dfu_status;\n  }\n\n  private poll_until_idle(idle_state: number) {\n    return this.poll_until((state: number) => state == idle_state);\n  }\n\n  private async do_read(\n    process: WebDFUProcessRead,\n    xfer_size: number,\n    max_size = Infinity,\n    first_block = 0\n  ): Promise<Blob> {\n    let transaction = first_block;\n    let blocks = [];\n    let bytes_read = 0;\n\n    // Initialize progress to 0\n    process.events.emit(\"process\", 0);\n\n    let result;\n    let bytes_to_read;\n    do {\n      bytes_to_read = Math.min(xfer_size, max_size - bytes_read);\n      result = await this.upload(bytes_to_read, transaction++);\n      if (result.byteLength > 0) {\n        blocks.push(result);\n        bytes_read += result.byteLength;\n      }\n\n      process.events.emit(\"process\", bytes_read, Number.isFinite(max_size) ? max_size : undefined);\n    } while (bytes_read < max_size && result.byteLength == bytes_to_read);\n\n    if (bytes_read == max_size) {\n      await this.abortToIdle();\n    }\n\n    return new Blob(blocks, { type: \"application/octet-stream\" });\n  }\n\n  private async do_write(\n    process: WebDFUProcessWrite,\n    xfer_size: number,\n    data: ArrayBuffer,\n    manifestationTolerant = true\n  ): Promise<void> {\n    let bytes_sent = 0;\n    let expected_size = data.byteLength;\n    let transaction = 0;\n\n    process.events.emit(\"write/start\");\n\n    // Initialize progress to 0\n    process.events.emit(\"write/process\", bytes_sent, expected_size);\n\n    while (bytes_sent < expected_size) {\n      const bytes_left = expected_size - bytes_sent;\n      const chunk_size = Math.min(bytes_left, xfer_size);\n\n      let bytes_written = 0;\n      let dfu_status;\n      try {\n        bytes_written = await this.download(data.slice(bytes_sent, bytes_sent + chunk_size), transaction++);\n        dfu_status = await this.poll_until_idle(dfuCommands.dfuDOWNLOAD_IDLE);\n      } catch (error) {\n        throw new WebDFUError(\"Error during DFU download: \" + error);\n      }\n\n      if (dfu_status.status != dfuCommands.STATUS_OK) {\n        throw new WebDFUError(`DFU DOWNLOAD failed state=${dfu_status.state}, status=${dfu_status.status}`);\n      }\n\n      bytes_sent += bytes_written;\n\n      process.events.emit(\"write/process\", bytes_sent, expected_size);\n    }\n\n    try {\n      await this.download(new ArrayBuffer(0), transaction++);\n    } catch (error) {\n      throw new WebDFUError(\"Error during final DFU download: \" + error);\n    }\n\n    process.events.emit(\"write/end\", bytes_sent);\n\n    if (manifestationTolerant) {\n      // Transition to MANIFEST_SYNC state\n      let dfu_status;\n      try {\n        // Wait until it returns to idle.\n        // If it's not really manifestation tolerant, it might transition to MANIFEST_WAIT_RESET\n        dfu_status = await this.poll_until(\n          (state) => state == dfuCommands.dfuIDLE || state == dfuCommands.dfuMANIFEST_WAIT_RESET\n        );\n\n        // if dfu_status.state == dfuCommands.dfuMANIFEST_WAIT_RESET\n        // => Device transitioned to MANIFEST_WAIT_RESET even though it is manifestation tolerant\n\n        if (dfu_status.status != dfuCommands.STATUS_OK) {\n          throw new WebDFUError(`DFU MANIFEST failed state=${dfu_status.state}, status=${dfu_status.status}`);\n        }\n      } catch (error) {\n        if (\n          error.endsWith(\"ControlTransferIn failed: NotFoundError: Device unavailable.\") ||\n          error.endsWith(\"ControlTransferIn failed: NotFoundError: The device was disconnected.\")\n        ) {\n          this.log.warning(\"Unable to poll final manifestation status\");\n        } else {\n          throw new WebDFUError(\"Error during DFU manifest: \" + error);\n        }\n      }\n    } else {\n      // Try polling once to initiate manifestation\n      try {\n        await this.getStatus();\n      } catch (error) {}\n    }\n\n    // Reset to exit MANIFEST_WAIT_RESET\n    try {\n      await this.device.reset();\n    } catch (error) {\n      if (\n        error == \"NetworkError: Unable to reset the device.\" ||\n        error == \"NotFoundError: Device unavailable.\" ||\n        error == \"NotFoundError: The device was disconnected.\"\n      ) {\n        // Ignored reset error\n      } else {\n        throw new WebDFUError(\"Error during reset for manifestation: \" + error);\n      }\n    }\n  }\n\n  // DFUse specific\n  private async do_dfuse_write(process: WebDFUProcessWrite, xfer_size: number, data: ArrayBuffer) {\n    if (!this.dfuseMemoryInfo || !this.dfuseMemoryInfo.segments) {\n      throw new WebDFUError(\"No memory map available\");\n    }\n\n    process.events.emit(\"erase/start\");\n\n    let bytes_sent = 0;\n    let expected_size = data.byteLength;\n\n    let startAddress: number | undefined = this.dfuseStartAddress;\n\n    if (isNaN(startAddress)) {\n      startAddress = this.dfuseMemoryInfo.segments[0]?.start;\n\n      if (!startAddress) {\n        throw new WebDFUError(\"startAddress not found\");\n      }\n\n      this.log.warning(\"Using inferred start address 0x\" + startAddress.toString(16));\n    } else if (this.getDfuseSegment(startAddress) === null && data.byteLength !== 0) {\n      throw new WebDFUError(`Start address 0x${startAddress.toString(16)} outside of memory map bounds`);\n    }\n\n    await new Promise<void>((resolve, reject) => {\n      if (!startAddress) {\n        reject(new WebDFUError(\"startAddress not found\"));\n        return;\n      }\n\n      const ev = this.erase(startAddress, expected_size);\n\n      ev.events.on(\"process\", (...args) => process.events.emit(\"erase/process\", ...args));\n      ev.events.on(\"error\", reject);\n      ev.events.on(\"end\", () => {\n        process.events.emit(\"erase/end\");\n        resolve();\n      });\n    });\n\n    process.events.emit(\"write/start\");\n\n    let address = startAddress;\n    while (bytes_sent < expected_size) {\n      const bytes_left = expected_size - bytes_sent;\n      const chunk_size = Math.min(bytes_left, xfer_size);\n\n      let bytes_written = 0;\n      let dfu_status;\n      try {\n        await this.dfuseCommand(DFUseCommands.SET_ADDRESS, address, 4);\n        bytes_written = await this.download(data.slice(bytes_sent, bytes_sent + chunk_size), 2);\n        dfu_status = await this.poll_until_idle(dfuCommands.dfuDOWNLOAD_IDLE);\n        address += chunk_size;\n      } catch (error) {\n        throw new WebDFUError(\"Error during DfuSe download: \" + error);\n      }\n\n      if (dfu_status.status != dfuCommands.STATUS_OK) {\n        throw new WebDFUError(`DFU DOWNLOAD failed state=${dfu_status.state}, status=${dfu_status.status}`);\n      }\n\n      bytes_sent += bytes_written;\n\n      process.events.emit(\"write/process\", bytes_sent, expected_size);\n    }\n\n    process.events.emit(\"write/end\", bytes_sent);\n\n    try {\n      await this.dfuseCommand(DFUseCommands.SET_ADDRESS, startAddress, 4);\n      await this.download(new ArrayBuffer(0), 0);\n    } catch (error) {\n      throw new WebDFUError(\"Error during DfuSe manifestation: \" + error);\n    }\n\n    await this.poll_until((state) => state == dfuCommands.dfuMANIFEST);\n  }\n\n  private async do_dfuse_read(process: WebDFUProcessRead, xfer_size: number, max_size = Infinity) {\n    if (!this.dfuseMemoryInfo) {\n      throw new WebDFUError(\"Unknown a DfuSe memory info\");\n    }\n\n    let startAddress: number | undefined = this.dfuseStartAddress;\n    if (isNaN(startAddress)) {\n      startAddress = this.dfuseMemoryInfo.segments[0]?.start;\n      if (!startAddress) {\n        throw new WebDFUError(\"Unknown memory segments\");\n      }\n      this.log.warning(\"Using inferred start address 0x\" + startAddress.toString(16));\n    } else if (this.getDfuseSegment(startAddress) === null) {\n      this.log.warning(`Start address 0x${startAddress.toString(16)} outside of memory map bounds`);\n    }\n\n    let state = await this.getState();\n    if (state != dfuCommands.dfuIDLE) {\n      await this.abortToIdle();\n    }\n    await this.dfuseCommand(DFUseCommands.SET_ADDRESS, startAddress, 4);\n    await this.abortToIdle();\n\n    // DfuSe encodes the read address based on the transfer size,\n    // the block number - 2, and the SET_ADDRESS pointer.\n    return await this.do_read(process, xfer_size, max_size, 2);\n  }\n\n  getDfuseSegment(addr: number): DFUseMemorySegment | null {\n    if (!this.dfuseMemoryInfo || !this.dfuseMemoryInfo.segments) {\n      throw new WebDFUError(\"No memory map information available\");\n    }\n\n    for (let segment of this.dfuseMemoryInfo.segments) {\n      if (segment.start <= addr && addr < segment.end) {\n        return segment;\n      }\n    }\n\n    return null;\n  }\n\n  getDfuseFirstWritableSegment() {\n    if (!this.dfuseMemoryInfo || !this.dfuseMemoryInfo.segments) {\n      throw new WebDFUError(\"No memory map information available\");\n    }\n\n    for (let segment of this.dfuseMemoryInfo.segments) {\n      if (segment.writable) {\n        return segment;\n      }\n    }\n\n    return null;\n  }\n\n  getDfuseMaxReadSize(startAddr: number) {\n    if (!this.dfuseMemoryInfo || !this.dfuseMemoryInfo.segments) {\n      throw new WebDFUError(\"No memory map information available\");\n    }\n\n    let numBytes = 0;\n    for (let segment of this.dfuseMemoryInfo.segments) {\n      if (segment.start <= startAddr && startAddr < segment.end) {\n        // Found the first segment the read starts in\n        if (segment.readable) {\n          numBytes += segment.end - startAddr;\n        } else {\n          return 0;\n        }\n      } else if (segment.start == startAddr + numBytes) {\n        // Include a contiguous segment\n        if (segment.readable) {\n          numBytes += segment.end - segment.start;\n        } else {\n          break;\n        }\n      }\n    }\n\n    return numBytes;\n  }\n\n  private getDfuseSectorStart(addr: number, segment: DFUseMemorySegment | null) {\n    if (typeof segment === \"undefined\") {\n      segment = this.getDfuseSegment(addr);\n    }\n\n    if (!segment) {\n      throw new WebDFUError(`Address ${addr.toString(16)} outside of memory map`);\n    }\n\n    const sectorIndex = Math.floor((addr - segment.start) / segment.sectorSize);\n    return segment.start + sectorIndex * segment.sectorSize;\n  }\n\n  private getDfuseSectorEnd(addr: number, segment = this.getDfuseSegment(addr)) {\n    if (!segment) {\n      throw new WebDFUError(`Address ${addr.toString(16)} outside of memory map`);\n    }\n\n    const sectorIndex = Math.floor((addr - segment.start) / segment.sectorSize);\n    return segment.start + (sectorIndex + 1) * segment.sectorSize;\n  }\n\n  private erase(startAddr: number, length: number): WebDFUProcessErase {\n    const process = new WebDFUProcessErase();\n\n    const that = this;\n    void (async function () {\n      let segment = that.getDfuseSegment(startAddr);\n      let addr = that.getDfuseSectorStart(startAddr, segment);\n      const endAddr = that.getDfuseSectorEnd(startAddr + length - 1);\n\n      if (!segment) {\n        throw new WebDFUError(\"Unknown segment\");\n      }\n\n      let bytesErased = 0;\n      const bytesToErase = endAddr - addr;\n      if (bytesToErase > 0) {\n        process.events.emit(\"process\", bytesErased, bytesToErase);\n      }\n\n      while (addr < endAddr) {\n        if ((segment?.end ?? 0) <= addr) {\n          segment = that.getDfuseSegment(addr);\n        }\n\n        if (!segment?.erasable) {\n          // Skip over the non-erasable section\n          bytesErased = Math.min(bytesErased + (segment?.end ?? 0) - addr, bytesToErase);\n          addr = segment?.end ?? 0;\n        } else {\n          const sectorIndex = Math.floor((addr - segment.start) / segment.sectorSize);\n          const sectorAddr = segment.start + sectorIndex * segment.sectorSize;\n          await that.dfuseCommand(DFUseCommands.ERASE_SECTOR, sectorAddr, 4);\n          addr = sectorAddr + segment.sectorSize;\n          bytesErased += segment.sectorSize;\n        }\n\n        process.events.emit(\"process\", bytesErased, bytesToErase);\n      }\n    })()\n      .then(() => process.events.emit(\"end\"))\n      .catch((error) => process.events.emit(\"error\", error));\n\n    return process;\n  }\n\n  private async dfuseCommand(command: number, param = 0x00, len = 1) {\n    const commandNames: Record<number, string> = {\n      [DFUseCommands.GET_COMMANDS]: \"GET_COMMANDS\",\n      [DFUseCommands.SET_ADDRESS]: \"SET_ADDRESS\",\n      [DFUseCommands.ERASE_SECTOR]: \"ERASE_SECTOR\",\n    };\n\n    let payload = new ArrayBuffer(len + 1);\n    let view = new DataView(payload);\n    view.setUint8(0, command);\n    if (len == 1) {\n      view.setUint8(1, param);\n    } else if (len == 4) {\n      view.setUint32(1, param, true);\n    } else {\n      throw new WebDFUError(\"Don't know how to handle data of len \" + len);\n    }\n\n    try {\n      await this.download(payload, 0);\n    } catch (error) {\n      throw new WebDFUError(\"Error during special DfuSe command \" + commandNames[command] + \":\" + error);\n    }\n\n    let status = await this.poll_until((state) => state != dfuCommands.dfuDNBUSY);\n\n    if (status.status != dfuCommands.STATUS_OK) {\n      throw new WebDFUError(\"Special DfuSe command \" + command + \" failed\");\n    }\n  }\n}\n","let logContext: HTMLDivElement | null = null;\n\nexport function setLogContext(div: HTMLDivElement | null): void {\n  logContext = div;\n}\n\nexport function clearLog(context = logContext): void {\n  if (context) {\n    context.innerHTML = \"\";\n  }\n}\n\nexport function logInfo(msg: string): void {\n  if (logContext) {\n    const info = document.createElement(\"p\");\n    info.className = \"info\";\n    info.textContent = msg;\n    logContext.appendChild(info);\n  }\n}\n\nexport function logWarning(msg: string): void {\n  if (logContext) {\n    const warning = document.createElement(\"p\");\n    warning.className = \"warning\";\n    warning.textContent = msg;\n    logContext.appendChild(warning);\n  }\n}\n\nexport function logError(msg: string): void {\n  console.error(msg);\n  if (logContext) {\n    const error = document.createElement(\"p\");\n    error.className = \"error\";\n    error.textContent = msg;\n    logContext.appendChild(error);\n  }\n}\n\nexport function logProgress(done: number, total?: number): void {\n  if (logContext) {\n    let progressBar: HTMLProgressElement | null = null;\n    if (logContext?.lastElementChild?.tagName.toLowerCase() == \"progress\") {\n      progressBar = logContext.lastElementChild as HTMLProgressElement;\n    }\n\n    if (!progressBar) {\n      progressBar = document.createElement(\"progress\");\n      logContext.appendChild(progressBar);\n    }\n\n    progressBar.value = done;\n    if (total !== undefined) {\n      progressBar.max = total;\n    }\n  }\n}\n","import { saveAs } from \"file-saver\";\nimport { WebDFUType, WebDFU } from \"dfu/index\";\n\nimport { clearLog, logError, logInfo, logProgress, logWarning, setLogContext } from \"./log\";\n\n// Utils\nfunction hex4(n: number) {\n  let s = n.toString(16);\n\n  while (s.length < 4) {\n    s = \"0\" + s;\n  }\n\n  return s;\n}\n\nfunction hexAddr8(n: number) {\n  let s = n.toString(16);\n  while (s.length < 8) {\n    s = \"0\" + s;\n  }\n  return \"0x\" + s;\n}\n\nfunction niceSize(n: number) {\n  const gigabyte = 1024 * 1024 * 1024;\n  const megabyte = 1024 * 1024;\n  const kilobyte = 1024;\n  if (n >= gigabyte) {\n    return n / gigabyte + \"GiB\";\n  } else if (n >= megabyte) {\n    return n / megabyte + \"MiB\";\n  } else if (n >= kilobyte) {\n    return n / kilobyte + \"KiB\";\n  } else {\n    return n + \"B\";\n  }\n}\n\nfunction formatDFUSummary(device: WebDFU) {\n  const vid = hex4(device.device.vendorId);\n  const pid = hex4(device.device.productId);\n  const name = device.device.productName;\n\n  let mode = \"Unknown\";\n  if (device.currentInterfaceSettings?.alternate.interfaceProtocol == 0x01) {\n    mode = \"Runtime\";\n  } else if (device.currentInterfaceSettings?.alternate.interfaceProtocol == 0x02) {\n    mode = \"DFU\";\n  }\n\n  const cfg = device.currentInterfaceSettings?.configuration.configurationValue;\n  const intf = device.currentInterfaceSettings?.[\"interface\"].interfaceNumber;\n  const alt = device.currentInterfaceSettings?.alternate.alternateSetting;\n  const serial = device.device.serialNumber;\n\n  return `${mode}: [${vid}:${pid}] cfg=${cfg}, intf=${intf}, alt=${alt}, name=\"${name}\" serial=\"${serial}\"`;\n}\n\n// Current page\nlet webdfu: WebDFU | null = null;\n\nconst connectButton = document.querySelector(\"#connect\") as HTMLButtonElement;\nconst downloadButton = document.querySelector(\"#download\") as HTMLButtonElement;\nconst uploadButton = document.querySelector(\"#upload\") as HTMLButtonElement;\nconst statusDisplay = document.querySelector(\"#status\") as HTMLDivElement;\nconst infoDisplay = document.querySelector(\"#usbInfo\") as HTMLDivElement;\nconst dfuDisplay = document.querySelector(\"#dfuInfo\") as HTMLDivElement;\n\nconst configForm = document.querySelector(\"#configForm\") as HTMLFormElement;\n\nconst transferSizeField = document.querySelector(\"#transferSize\") as HTMLInputElement;\nlet transferSize = parseInt(transferSizeField.value);\n\nconst dfuseStartAddressField = document.querySelector(\"#dfuseStartAddress\") as HTMLInputElement;\nconst dfuseUploadSizeField = document.querySelector(\"#dfuseUploadSize\") as HTMLInputElement;\n\nconst firmwareFileField = document.querySelector(\"#firmwareFile\") as HTMLInputElement;\nlet firmwareFile: ArrayBuffer | null = null;\n\nconst downloadLog = document.querySelector(\"#downloadLog\") as HTMLDivElement;\nconst uploadLog = document.querySelector(\"#uploadLog\") as HTMLDivElement;\n\nlet manifestationTolerant = true;\n\nfunction onDisconnect(reason?: Error) {\n  if (reason) {\n    statusDisplay.textContent = reason.message;\n  }\n\n  connectButton.textContent = \"Connect\";\n  infoDisplay.textContent = \"\";\n  dfuDisplay.textContent = \"\";\n  uploadButton.disabled = false;\n  downloadButton.disabled = true;\n  firmwareFileField.disabled = true;\n}\n\nfunction onUnexpectedDisconnect(event: USBConnectionEvent) {\n  if (webdfu?.device) {\n    if (webdfu?.device === event.device) {\n      onDisconnect(new Error(\"Device disconnected\"));\n      webdfu = null;\n    }\n  }\n}\n\nasync function connect(interfaceIndex: number) {\n  if (!webdfu) {\n    throw new Error();\n  }\n\n  await webdfu.connect(interfaceIndex);\n\n  let memorySummary = \"\";\n  if (webdfu.properties) {\n    const desc = webdfu.properties;\n\n    const info = [\n      `WillDetach=${webdfu.properties.WillDetach}`,\n      `ManifestationTolerant=${webdfu.properties.ManifestationTolerant}`,\n      `CanUpload=${webdfu.properties.CanUpload}`,\n      `CanDownload=${webdfu.properties.CanDownload}`,\n      `TransferSize=${webdfu.properties.TransferSize}`,\n      `DetachTimeOut=${webdfu.properties.DetachTimeOut}`,\n      `Version=${hex4(webdfu.properties.DFUVersion)}`,\n    ];\n\n    dfuDisplay.textContent += \"\\n\" + info.join(\", \");\n    transferSizeField.value = webdfu.properties.TransferSize.toString();\n    transferSize = webdfu.properties.TransferSize;\n\n    if (webdfu.properties.CanDownload) {\n      manifestationTolerant = webdfu.properties.ManifestationTolerant;\n    }\n\n    if (webdfu.currentInterfaceSettings?.alternate.interfaceProtocol == 0x02) {\n      if (!desc.CanUpload) {\n        uploadButton.disabled = false;\n        dfuseUploadSizeField.disabled = true;\n      }\n\n      if (!desc.CanDownload) {\n        downloadButton.disabled = true;\n      }\n    }\n\n    if (webdfu.type === WebDFUType.SDFUse) {\n      if (webdfu.dfuseMemoryInfo) {\n        let totalSize = 0;\n        for (const segment of webdfu.dfuseMemoryInfo.segments) {\n          totalSize += segment.end - segment.start;\n        }\n        memorySummary = `Selected memory region: ${webdfu.dfuseMemoryInfo.name} (${niceSize(totalSize)})`;\n        for (const segment of webdfu.dfuseMemoryInfo.segments) {\n          const properties = [];\n          if (segment.readable) {\n            properties.push(\"readable\");\n          }\n          if (segment.erasable) {\n            properties.push(\"erasable\");\n          }\n          if (segment.writable) {\n            properties.push(\"writable\");\n          }\n          let propertySummary = properties.join(\", \");\n          if (!propertySummary) {\n            propertySummary = \"inaccessible\";\n          }\n\n          memorySummary += `\\n${hexAddr8(segment.start)}-${hexAddr8(segment.end - 1)} (${propertySummary})`;\n        }\n      }\n    }\n  }\n\n  // Clear logs\n  clearLog(uploadLog);\n  clearLog(downloadLog);\n\n  // Display basic USB information\n  statusDisplay.textContent = \"\";\n  connectButton.textContent = \"Disconnect\";\n  infoDisplay.textContent =\n    `Name: ${webdfu.device.productName}\\n` +\n    `MFG: ${webdfu.device.manufacturerName}\\n` +\n    `Serial: ${webdfu.device.serialNumber}\\n`;\n\n  // Display basic dfu-util style info\n  if (webdfu) {\n    dfuDisplay.textContent = formatDFUSummary(webdfu) + \"\\n\" + memorySummary;\n  } else {\n    dfuDisplay.textContent = \"Not found\";\n  }\n\n  // Update buttons based on capabilities\n  if (webdfu.currentInterfaceSettings?.alternate.interfaceProtocol == 0x01) {\n    // Runtime\n    uploadButton.disabled = false;\n    downloadButton.disabled = true;\n    firmwareFileField.disabled = true;\n  } else {\n    // DFU\n    uploadButton.disabled = false;\n    downloadButton.disabled = false;\n    firmwareFileField.disabled = false;\n  }\n\n  if (webdfu.type === WebDFUType.SDFUse && webdfu.dfuseMemoryInfo) {\n    const dfuseFieldsDiv = document.querySelector(\"#dfuseFields\") as HTMLDivElement;\n    dfuseFieldsDiv.hidden = false;\n    dfuseStartAddressField.disabled = false;\n    dfuseUploadSizeField.disabled = false;\n    const segment = webdfu.getDfuseFirstWritableSegment();\n    if (segment) {\n      webdfu.dfuseStartAddress = segment.start;\n      dfuseStartAddressField.value = \"0x\" + segment.start.toString(16);\n      const maxReadSize = webdfu.getDfuseMaxReadSize(segment.start);\n      dfuseUploadSizeField.value = maxReadSize.toString();\n      dfuseUploadSizeField.max = maxReadSize.toString();\n    }\n  } else {\n    const dfuseFieldsDiv = document.querySelector(\"#dfuseFields\") as HTMLDivElement;\n    dfuseFieldsDiv.hidden = true;\n    dfuseStartAddressField.disabled = true;\n    dfuseUploadSizeField.disabled = true;\n  }\n}\n\ntransferSizeField.addEventListener(\"change\", () => {\n  transferSize = parseInt(transferSizeField.value);\n});\n\ndfuseStartAddressField.addEventListener(\"change\", function (event) {\n  const field = event.target as HTMLInputElement;\n  const address = parseInt(field.value, 16);\n  if (isNaN(address)) {\n    field.setCustomValidity(\"Invalid hexadecimal start address\");\n  } else if (webdfu && webdfu.type === WebDFUType.SDFUse && webdfu?.dfuseMemoryInfo) {\n    if (webdfu.getDfuseSegment(address) !== null) {\n      webdfu.dfuseStartAddress = address;\n      field.setCustomValidity(\"\");\n      if (webdfu && webdfu.type === WebDFUType.SDFUse) {\n        dfuseUploadSizeField.max = webdfu.getDfuseMaxReadSize(address).toString();\n      }\n    } else {\n      field.setCustomValidity(\"Address outside of memory map\");\n    }\n  } else {\n    field.setCustomValidity(\"\");\n  }\n});\n\nconnectButton.addEventListener(\"click\", function () {\n  if (webdfu) {\n    webdfu.close().catch(console.error);\n    webdfu = null;\n\n    return;\n  }\n\n  navigator.usb\n    .requestDevice({ filters: [] })\n    .then(async (selectedDevice) => {\n      webdfu = new WebDFU(\n        selectedDevice,\n        {\n          forceInterfacesName: true,\n        },\n        {\n          info: logInfo,\n          warning: logWarning,\n          progress: logProgress,\n        }\n      );\n      webdfu.events.on(\"disconnect\", onDisconnect);\n\n      await webdfu.init();\n\n      if (webdfu.interfaces.length == 0) {\n        statusDisplay.textContent = \"The selected device does not have any USB DFU interfaces.\";\n        return;\n      }\n\n      await connect(0);\n    })\n    .catch((error) => {\n      console.log(error);\n      statusDisplay.textContent = error;\n    });\n});\n\nuploadButton.addEventListener(\"click\", async function (event) {\n  event.preventDefault();\n  event.stopPropagation();\n  if (!configForm.checkValidity()) {\n    configForm.reportValidity();\n    return false;\n  }\n\n  if (!webdfu || !webdfu.device.opened) {\n    onDisconnect();\n    webdfu = null;\n  } else {\n    setLogContext(uploadLog);\n    clearLog(uploadLog);\n    try {\n      if (await webdfu.isError()) {\n        await webdfu.clearStatus();\n      }\n    } catch (error) {\n      logWarning(\"Failed to clear status\");\n    }\n\n    let maxSize = Infinity;\n    if (!dfuseUploadSizeField.disabled) {\n      maxSize = parseInt(dfuseUploadSizeField.value);\n    }\n\n    const process = webdfu.read(transferSize, maxSize);\n\n    // after start\n    if (webdfu?.type === WebDFUType.SDFUse) {\n      logInfo(`Reading up to 0x${maxSize.toString(16)} bytes starting at 0x${webdfu.dfuseStartAddress.toString(16)}`);\n    }\n\n    logInfo(\"Copying data from DFU device to browser\");\n\n    process.events.on(\"process\", (done, total) => {\n      logProgress(done, total);\n    });\n\n    process.events.on(\"error\", (error) => {\n      logError(error);\n      setLogContext(null);\n    });\n\n    process.events.on(\"end\", (blob) => {\n      console.log(\"end?\");\n      logInfo(`Read ${blob.size} bytes`);\n      setLogContext(null);\n\n      saveAs(blob, \"firmware.bin\");\n    });\n  }\n\n  return false;\n});\n\nfirmwareFileField.addEventListener(\"change\", function () {\n  firmwareFile = null;\n  if ((firmwareFileField?.files ?? []).length > 0) {\n    const file = firmwareFileField.files?.[0] as Blob;\n    const reader = new FileReader();\n    reader.onload = function () {\n      if (reader.result instanceof ArrayBuffer) {\n        firmwareFile = reader.result;\n      }\n    };\n    reader.readAsArrayBuffer(file);\n  }\n});\n\nasync function download(): Promise<void> {\n  if (!configForm.checkValidity()) {\n    configForm.reportValidity();\n    return;\n  }\n\n  if (webdfu && firmwareFile != null) {\n    setLogContext(downloadLog);\n    clearLog(downloadLog);\n\n    try {\n      if (await webdfu.isError()) {\n        await webdfu.clearStatus();\n      }\n    } catch (error) {\n      logWarning(\"Failed to clear status\");\n    }\n\n    const process = webdfu.write(transferSize, firmwareFile, manifestationTolerant);\n\n    // Erase\n    process.events.on(\"erase/start\", () => {\n      console.log(\"erase/start!\");\n      logInfo(\"Erasing DFU device memory\");\n    });\n\n    process.events.on(\"erase/process\", (bytesSent, expectedSize) => {\n      logProgress(bytesSent, expectedSize);\n    });\n\n    process.events.on(\"erase/end\", () => {\n      logInfo(\"Success erased\");\n    });\n\n    // Write firmware\n    process.events.on(\"write/start\", () => {\n      logInfo(\"Copying data from browser to DFU device\");\n    });\n\n    process.events.on(\"write/process\", (bytesSent, expectedSize) => {\n      logProgress(bytesSent, expectedSize);\n    });\n\n    process.events.on(\"write/end\", (bytes_sent: number) => {\n      logInfo(`Wrote ${bytes_sent} bytes`);\n      logInfo(\"Manifesting new firmware\");\n\n      webdfu\n        ?.getStatus()\n        .then((status) => {\n          logInfo(`Final DFU status: state=${status.state}, status=${status.status}`);\n        })\n        .catch((error) => {\n          logError(error);\n        });\n    });\n\n    process.events.on(\"error\", (error) => {\n      logError(error);\n      setLogContext(null);\n    });\n\n    process.events.on(\"end\", () => {\n      logInfo(\"Done!\");\n      setLogContext(null);\n\n      if (!manifestationTolerant) {\n        webdfu\n          ?.waitDisconnected(5000)\n          .then(() => {\n            onDisconnect();\n            webdfu = null;\n          })\n          .catch(() => {\n            // It didn't reset and disconnect for some reason...\n            console.error(\"Device unexpectedly tolerated manifestation.\");\n          });\n      }\n    });\n  }\n}\n\ndownloadButton.addEventListener(\"click\", async function (event) {\n  event.preventDefault();\n  event.stopPropagation();\n\n  download().catch(console.error);\n});\n\nif (typeof navigator.usb === \"undefined\") {\n  statusDisplay.textContent = \"WebUSB not available.\";\n  connectButton.disabled = true;\n} else {\n  navigator.usb.addEventListener(\"disconnect\", onUnexpectedDisconnect);\n}\n"],"names":["a","b","$parcel$global","globalThis","self","window","global","c","d","XMLHttpRequest","open","responseType","onload","g","response","onerror","console","error","send","status","e","dispatchEvent","MouseEvent","document","createEvent","initMouseEvent","f","navigator","test","userAgent","saveAs","HTMLAnchorElement","prototype","h","i","URL","webkitURL","j","createElement","name","download","rel","href","origin","location","target","createObjectURL","setTimeout","revokeObjectURL","msSaveOrOpenBlob","autoBom","warn","type","Blob","title","body","innerText","HTMLElement","safari","FileReader","k","onloadend","result","replace","readAsDataURL","l","m","$8236ddbebe8d5d23c3d281082892fc6d$exports","FileSaver","exports","$fec02f39044083388e60edb2ee080f76$var$cachedSetTimeout","$fec02f39044083388e60edb2ee080f76$var$cachedClearTimeout","$fec02f39044083388e60edb2ee080f76$var$process","$fec02f39044083388e60edb2ee080f76$var$defaultSetTimout","Error","$fec02f39044083388e60edb2ee080f76$var$defaultClearTimeout","$fec02f39044083388e60edb2ee080f76$var$runTimeout","fun","call","this","clearTimeout","$fec02f39044083388e60edb2ee080f76$var$currentQueue","$fec02f39044083388e60edb2ee080f76$var$queue","$fec02f39044083388e60edb2ee080f76$var$draining","$fec02f39044083388e60edb2ee080f76$var$queueIndex","$fec02f39044083388e60edb2ee080f76$var$cleanUpNextTick","length","concat","$fec02f39044083388e60edb2ee080f76$var$drainQueue","timeout","len","run","marker","$fec02f39044083388e60edb2ee080f76$var$runClearTimeout","$fec02f39044083388e60edb2ee080f76$var$Item","array","$fec02f39044083388e60edb2ee080f76$var$noop","$769e2bc93d49d89e5c8ef54438a2c762$export$DFUseCommands","DFUseCommands","nextTick","args","Array","arguments","push","apply","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","$769e2bc93d49d89e5c8ef54438a2c762$export$WebDFUType","$769e2bc93d49d89e5c8ef54438a2c762$export$WebDFUError","$769e2bc93d49d89e5c8ef54438a2c762$export$parseFunctionalDescriptor","data","bLength","getUint8","bDescriptorType","bmAttributes","wDetachTimeOut","getUint16","wTransferSize","bcdDFUVersion","$769e2bc93d49d89e5c8ef54438a2c762$export$parseConfigurationDescriptor","descriptors","descriptorData","currIntf","remainingData","inDfuIntf","byteLength","descData","DataView","buffer","slice","bInterfaceNumber","bAlternateSetting","bNumEndpoints","bInterfaceClass","bInterfaceSubClass","bInterfaceProtocol","iInterface","DT_DFU_FUNCTIONAL","funcDesc","desc","$769e2bc93d49d89e5c8ef54438a2c762$export$parseSubDescriptors","wTotalLength","bNumInterfaces","bConfigurationValue","iConfiguration","bMaxPower","$6b08257e91729d7e71b855ce3d7ae5f9$export$WebDFUProcessRead","events","event","forEach","cb","filter","$6b08257e91729d7e71b855ce3d7ae5f9$export$WebDFUProcessWrite","$6b08257e91729d7e71b855ce3d7ae5f9$export$WebDFUProcessErase","$7aab2205d80d1c7fb23fb2d0282aebd5$export$dfuCommands","$7aab2205d80d1c7fb23fb2d0282aebd5$export$WebDFU","interfaces","connected","dfuseStartAddress","NaN","constructor","device","settings","log","properties","DFUVersion","currentInterfaceSettings","_this$currentInterfac","alternate","interfaceProtocol","findDfuInterfaces","interfaceIndex","opened","getDFUDescriptorProperties","intrf","dfuseMemoryInfo","nameEndIndex","indexOf","startsWith","substring","trim","segmentString","segments","sectorMultipliers"," ","B","K","M","contiguousSegmentMatch","contiguousSegmentRegex","exec","segmentMatch","segmentRegex","startAddress","parseInt","sectorCount","sectorSize","_ref","charCodeAt","segment","start","end","readable","erasable","writable","close","read","xferSize","maxSize","process","blob","do_dfuse_read","do_read","then","catch","write","xfer_size","manifestationTolerant","do_dfuse_write","do_write","configDesc","readConfigurationDescriptor","configValue","configuration","configurationValue","hasOwnProperty","WillDetach","ManifestationTolerant","CanUpload","CanDownload","TransferSize","DetachTimeOut","conf","configurations","intf","alt","alternates","interfaceClass","interfaceSubclass","interface","interfaceName","forceInterfacesName","fixInterfaceNames","some","selectConfiguration","mapping","readInterfaceNames","configIndex","intfNumber","interfaceNumber","alternateSetting","toString","index","langID","request_setup","requestType","recipient","request","value","DT_STRING","controlTransferIn","u16_words","String","fromCharCode","DT_DEVICE","configs","allStringIndices","Set","add","strings","readStringDescriptor","config","Object","values","setup","DT_CONFIGURATION","descriptorSize","wLength","descriptor","confValue","claimed","claimInterface","altSetting","selectAlternateInterface","detach","requestOut","undefined","abort","usbDevice","Promise","resolve","reject","timeoutID","onDisconnect","usb","removeEventListener","stopPropagation","addEventListener","state","getStatus","_","getState","requestIn","pollTimeout","getUint32","clearStatus","bRequest","wValue","controlTransferOut","bytesWritten","blockNum","upload","state_predicate","dfu_status","async_sleep","duration_ms","poll_until_idle","idle_state","poll_until","max_size","Infinity","first_block","bytes_to_read","transaction","blocks","bytes_read","Math","min","Number","isFinite","abortToIdle","bytes_sent","expected_size","bytes_left","chunk_size","bytes_written","ArrayBuffer","endsWith","warning","reset","isNaN","_this$dfuseMemoryInfo","getDfuseSegment","ev","erase","address","dfuseCommand","SET_ADDRESS","_this$dfuseMemoryInfo2","addr","getDfuseFirstWritableSegment","getDfuseMaxReadSize","startAddr","numBytes","getDfuseSectorStart","sectorIndex","floor","getDfuseSectorEnd","that","endAddr","bytesErased","bytesToErase","sectorAddr","ERASE_SECTOR","command","param","commandNames","GET_COMMANDS","payload","view","setUint8","setUint32","$2048de6041f1e38cf186df2d18c718e7$var$logContext","$2048de6041f1e38cf186df2d18c718e7$export$setLogContext","div","$2048de6041f1e38cf186df2d18c718e7$export$clearLog","context","innerHTML","$2048de6041f1e38cf186df2d18c718e7$export$logInfo","msg","info","className","textContent","appendChild","$2048de6041f1e38cf186df2d18c718e7$export$logWarning","$2048de6041f1e38cf186df2d18c718e7$export$logError","$2048de6041f1e38cf186df2d18c718e7$export$logProgress","done","total","progressBar","lastElementChild","tagName","toLowerCase","max","$47381631461028c43dc09094c3fbadcc$var$hex4","n","s","$47381631461028c43dc09094c3fbadcc$var$hexAddr8","$47381631461028c43dc09094c3fbadcc$var$webdfu","$47381631461028c43dc09094c3fbadcc$var$connectButton","querySelector","$47381631461028c43dc09094c3fbadcc$var$downloadButton","$47381631461028c43dc09094c3fbadcc$var$uploadButton","$47381631461028c43dc09094c3fbadcc$var$statusDisplay","$47381631461028c43dc09094c3fbadcc$var$infoDisplay","$47381631461028c43dc09094c3fbadcc$var$dfuDisplay","$47381631461028c43dc09094c3fbadcc$var$configForm","$47381631461028c43dc09094c3fbadcc$var$transferSizeField","$47381631461028c43dc09094c3fbadcc$var$transferSize","$47381631461028c43dc09094c3fbadcc$var$dfuseStartAddressField","$47381631461028c43dc09094c3fbadcc$var$dfuseUploadSizeField","$47381631461028c43dc09094c3fbadcc$var$firmwareFileField","$47381631461028c43dc09094c3fbadcc$var$firmwareFile","$47381631461028c43dc09094c3fbadcc$var$downloadLog","$47381631461028c43dc09094c3fbadcc$var$uploadLog","$47381631461028c43dc09094c3fbadcc$var$manifestationTolerant","$47381631461028c43dc09094c3fbadcc$var$onDisconnect","reason","message","disabled","async","$47381631461028c43dc09094c3fbadcc$var$connect","connect","memorySummary","join","totalSize","gigabyte","megabyte","$47381631461028c43dc09094c3fbadcc$var$niceSize","propertySummary","productName","manufacturerName","serialNumber","vid","vendorId","pid","productId","mode","cfg","$47381631461028c43dc09094c3fbadcc$var$formatDFUSummary","hidden","maxReadSize","field","setCustomValidity","SDFUse","requestDevice","filters","selectedDevice","progress","init","preventDefault","checkValidity","reportValidity","isError","size","files","file","reader","readAsArrayBuffer","bytesSent","expectedSize","waitDisconnected","$47381631461028c43dc09094c3fbadcc$var$download"],"version":3,"file":"index.728b2928.js.map"}